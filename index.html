<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Paradigm Shift</title>
    
    <!-- Typography: Uni Sans -->
    <link href="https://fonts.cdnfonts.com/css/uni-sans" rel="stylesheet">

    <style>
        :root {
            --bg-color: #000000;
            --gummy-pink: rgba(236, 64, 122, 0.4);
            --sugar-white: rgba(255, 255, 255, 0.95);
            --accent-green: #55efc4;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg-color); 
            font-family: 'Uni Sans', sans-serif; 
            font-weight: 100; 
            touch-action: none;
            letter-spacing: 1px; 
        }

        /* --- INTRO ANIMATION --- */
        #intro-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0033; 
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            /* Increased delay to allow for longer text animation + buffer time */
            animation: fadeOutIntro 2s ease-in-out forwards;
            animation-delay: 5.5s; 
        }

        .intro-title {
            color: #ffffff;
            font-size: 10vw; 
            font-weight: 100;
            text-align: center;
            line-height: 0.9;
            opacity: 0;
            /* Extended duration to 5s for a slower, more cinematic feel */
            animation: cinematicText 5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
            animation-delay: 0.5s;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }

        @keyframes cinematicText {
            0% {
                opacity: 0;
                letter-spacing: -10px;
                transform: scale(0.95);
                filter: blur(10px);
            }
            100% {
                opacity: 1;
                letter-spacing: 5px; 
                transform: scale(1);
                filter: blur(0px);
            }
        }

        @keyframes fadeOutIntro {
            0% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }

        /* --- 1. CANVAS DYNAMICS --- */
        #syrup-bg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            overflow: hidden;
            background: #000000;
        }
        
        .blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(50px);
            opacity: 0.6;
            animation: morph 10s infinite alternate ease-in-out;
        }
        .blob:nth-child(1) { top: -10%; left: -10%; width: 50vw; height: 50vw; background: #ff9f43; animation-duration: 12s; }
        .blob:nth-child(2) { bottom: -20%; right: -10%; width: 60vw; height: 60vw; background: #ff5252; animation-duration: 15s; }
        .blob:nth-child(3) { top: 40%; left: 40%; width: 40vw; height: 40vw; background: #ffcccc; opacity: 0.3; animation-duration: 9s; }

        @keyframes morph {
            0% { transform: translate(0, 0) scale(1); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
            50% { transform: translate(20px, -20px) scale(1.1); border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; }
            100% { transform: translate(-20px, 20px) scale(0.9); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
        }

        /* --- 2. UI SURFACE --- */
        #ui {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            opacity: 0; 
            transition: opacity 1s ease-in;
        }

        .gummy-panel {
            background: var(--gummy-pink);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 24px;
            padding: 12.5px 20px;
            text-align: center;
            box-shadow: 
                inset 0 0 15px rgba(255,255,255,0.2), 
                0 15px 35px rgba(199, 21, 133, 0.25);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            min-width: 140px; 
        }

        .gummy-panel:active {
            transform: scale(0.95);
        }

        #level-indicator {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            font-size: 0.9rem;
            font-weight: 100;
            letter-spacing: 2px;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 18px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            opacity: 0; 
            transition: opacity 1s ease-in;
        }

        h1#object-name { 
            margin: 0; 
            font-size: 0.9rem; 
            font-weight: 100; 
            color: #fff;
            letter-spacing: 1px;
            text-shadow: 0 4px 12px rgba(233, 30, 99, 0.3);
            line-height: 1.2;
            text-transform: uppercase; 
        }

        /* Progress Bar */
        #sync-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 5;
        }
        #sync-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-green);
            background: linear-gradient(90deg, #55efc4, #00b894);
            box-shadow: 0 0 10px var(--accent-green);
            border-radius: 10px;
            transition: width 0.1s linear;
        }
        
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
    </style>
</head>
<body>

    <!-- Intro Animation Container -->
    <div id="intro-overlay">
        <div class="intro-title">PARADIGM<br>SHIFT</div>
    </div>

    <div id="syrup-bg">
        <div class="blob"></div>
        <div class="blob"></div>
        <div class="blob"></div>
    </div>

    <div id="level-indicator">LEVEL 1</div>
    
    <div id="sync-container">
        <div id="sync-bar"></div>
    </div>

    <div id="ui">
        <div class="gummy-panel">
            <h1 id="object-name">Find the...</h1>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

        // --- 1. RANDOM MUSIC ENGINE ---
        
        const songLibrary = [
            {
                title: "Paradigm Shift (Anamorphic Assembly) — S",
                // The game will look for a folder named 'music' in the same directory
                src: "music/Paradigm Shift (Anamorphic Assembly) — S.mp3" 
            },
            {
                title: "Paradigm Shift (Anamorphic Assembly) — S - Female",
                // New track added to the music folder path
                src: "music/Paradigm Shift (Anamorphic Assembly) — S - Female.mp3"
            }
        ];

        let currentAudio = null;
        let musicStarted = false;

        function initMusic() {
            if (musicStarted || songLibrary.length === 0) return;
            
            musicStarted = true;
            playRandomSong();
        }

        function playRandomSong() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            const randomIndex = Math.floor(Math.random() * songLibrary.length);
            const song = songLibrary[randomIndex];
            
            console.log("Playing:", song.title);

            currentAudio = new Audio(song.src);
            currentAudio.volume = 0.5; 
            
            currentAudio.onended = () => {
                playRandomSong();
            };

            currentAudio.play().catch(e => console.log("Audio play blocked or file missing:", e));
        }


        // --- 2. ENGINE SETUP ---
        const scene = new THREE.Scene();
        scene.background = null; 

        const width = window.innerWidth;
        const height = window.innerHeight;
        const aspect = width / height;
        const d = 10; 
        
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(0, 0, 20); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 3. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(5, 10, 10);
        scene.add(mainLight);
        
        const rimLight = new THREE.DirectionalLight(0xffffff, 1.0); 
        rimLight.position.set(-5, 5, -5);
        scene.add(rimLight);
        
        const sparkleLight = new THREE.PointLight(0xffffff, 1, 100);
        sparkleLight.position.set(0, 0, 10);
        scene.add(sparkleLight);

        // Flare FX
        const flareGeo = new THREE.RingGeometry(5.5, 6, 64);
        const flareMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0,
            side: THREE.DoubleSide
        });
        const flareMesh = new THREE.Mesh(flareGeo, flareMat);
        flareMesh.position.z = -8; 
        scene.add(flareMesh);

        // --- 4. SCULPTURE GENERATOR ---
        const puzzleGroup = new THREE.Group();
        scene.add(puzzleGroup);
        
        const boxGeo = new THREE.BoxGeometry(0.85, 0.85, 0.85); 
        
        const levels = [
            {
                name: "Raspberry Heart",
                color: 0xe84393, 
                map: [
                    "0110110",
                    "1111111",
                    "1111111",
                    "0111110",
                    "0011100",
                    "0001000"
                ]
            },
            {
                name: "Lemon Crown",
                color: 0xfdc500, 
                map: [
                    "1000001",
                    "1100011",
                    "1110111",
                    "1111111",
                    "1111111",
                    "0111110",
                    "0011100"
                ]
            },
            {
                name: "Berry Sword",
                color: 0x0984e3,
                map: [
                    "0001000",
                    "0001000",
                    "0001000",
                    "0001000",
                    "0111110",
                    "0001000",
                    "0001000",
                    "0001000",
                    "0001000",
                    "0011100"
                ]
            },
            {
                name: "Mint Chair",
                color: 0x00b894,
                map: [
                    "0010000",
                    "0010000",
                    "0010000",
                    "0011110",
                    "0010010",
                    "0010010",
                    "0010010"
                ]
            },
            {
                name: "Grape Invader",
                color: 0x6c5ce7, 
                map: [
                    "00100000100",
                    "00010001000",
                    "00111111100",
                    "01101110110",
                    "11111111111",
                    "10111111101",
                    "10100000101",
                    "00011011000"
                ]
            }
        ];

        let currentLevel = 0;
        let isSolved = false;
        let currentMat = null;
        let holdTimer = 0;
        const REQUIRED_HOLD = 1.5; 

        // HANDLE INTRO FADE - Adjusted timing to match new CSS animation durations (5.5s delay + 2s animation ~ 7.5s total)
        setTimeout(() => {
            const intro = document.getElementById('intro-overlay');
            if(intro) intro.style.display = 'none';
            document.getElementById('ui').style.opacity = 1;
            document.getElementById('level-indicator').style.opacity = 1;
        }, 7500); 

        function loadLevel(index) {
            if(index >= levels.length) {
                document.getElementById('object-name').innerText = "SUGAR RUSH COMPLETE";
                return;
            }

            const data = levels[index];
            currentLevel = index;
            isSolved = false;
            holdTimer = 0;
            
            document.getElementById('sync-bar').style.width = '0%';
            document.getElementById('sync-container').style.opacity = 0;
            flareMesh.material.opacity = 0;
            flareMesh.scale.set(1,1,1);
            solveSequenceTime = 0;
            
            while(puzzleGroup.children.length > 0){ 
                puzzleGroup.remove(puzzleGroup.children[0]); 
            }

            document.getElementById('level-indicator').innerText = `LEVEL ${index+1}`;
            document.getElementById('object-name').innerText = "Find the " + data.name;
            document.getElementById('object-name').style.opacity = 1;
            document.getElementById('object-name').style.color = "#fff";
            
            currentMat = new THREE.MeshPhysicalMaterial({ 
                color: data.color,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.6, 
                thickness: 1.5,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                ior: 1.5,
            });

            const rows = data.map.length;
            const cols = data.map[0].length;
            const offX = (cols - 1) / 2;
            const offY = (rows - 1) / 2;

            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(data.map[r][c] === '1') {
                        const mesh = new THREE.Mesh(boxGeo, currentMat);
                        const x = c - offX;
                        const y = (rows - 1 - r) - offY; 
                        const z = (Math.random() - 0.5) * 14; 
                        mesh.position.set(x, y, z);
                        puzzleGroup.add(mesh);
                    }
                }
            }

            puzzleGroup.rotation.x = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random());
            puzzleGroup.rotation.y = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random());
            puzzleGroup.rotation.z = (Math.random() - 0.5);
        }

        // --- 5. INTERACTION ---
        let isDragging = false;
        let prevPos = { x: 0, y: 0 };
        const TOLERANCE = 0.08; 

        function onDown(x, y) {
            // Start Music on first interaction (Browser Policy)
            if (!musicStarted) {
                initMusic();
            }

            if(isSolved) return;
            isDragging = true;
            prevPos = { x, y };
        }
        function onUp() { isDragging = false; }
        function onMove(x, y) {
            if(isDragging && !isSolved) {
                const dx = x - prevPos.x;
                const dy = y - prevPos.y;
                puzzleGroup.rotation.y += dx * 0.008;
                puzzleGroup.rotation.x += dy * 0.008;
                prevPos = { x, y };
            }
        }

        // --- 6. ANIMATION LOOP ---
        let solveSequenceTime = 0;
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if(isSolved) {
                solveSequenceTime += dt;
                
                if (solveSequenceTime < 1.0) {
                    const t = solveSequenceTime / 1.0;
                    const ease = 1 - Math.pow(1 - t, 3);
                    
                    puzzleGroup.rotation.set(
                        THREE.MathUtils.lerp(puzzleGroup.rotation.x, 0, 0.1),
                        THREE.MathUtils.lerp(puzzleGroup.rotation.y, 0, 0.1),
                        THREE.MathUtils.lerp(puzzleGroup.rotation.z, 0, 0.1)
                    );
                    
                    puzzleGroup.children.forEach(child => {
                        child.position.z = THREE.MathUtils.lerp(child.position.z, 0, 0.1);
                    });
                    
                    puzzleGroup.position.set(0,0,0);

                    flareMesh.material.opacity = Math.sin(t * Math.PI) * 0.8;
                    flareMesh.scale.setScalar(1 + t * 0.5);
                    
                    if (currentMat) {
                        currentMat.emissive.setHex(0xffffff);
                        currentMat.emissiveIntensity = ease * 0.8; 
                    }
                } 
                else if (solveSequenceTime < 2.5) {
                    puzzleGroup.rotation.set(0,0,0);
                    flareMesh.material.opacity = THREE.MathUtils.lerp(flareMesh.material.opacity, 0, 0.05);
                    if (currentMat) currentMat.emissiveIntensity = 0.2;
                }
                else {
                    loadLevel(currentLevel + 1);
                }
                
                document.getElementById('sync-container').style.opacity = 0;

            } else {
                const wrap = (r) => {
                    let a = r % (Math.PI * 2);
                    if (a > Math.PI) a -= Math.PI * 2;
                    if (a < -Math.PI) a += Math.PI * 2;
                    return a;
                }
                const rx = wrap(puzzleGroup.rotation.x);
                const ry = wrap(puzzleGroup.rotation.y);
                
                const isAligned = Math.abs(rx) < TOLERANCE && Math.abs(ry) < TOLERANCE;

                if (isAligned) {
                    holdTimer += dt;
                    
                    const intensity = (holdTimer / REQUIRED_HOLD) * 0.15;
                    puzzleGroup.position.set(
                        (Math.random() - 0.5) * intensity,
                        (Math.random() - 0.5) * intensity,
                        0
                    );
                    
                    flareMesh.material.opacity = (holdTimer / REQUIRED_HOLD) * 0.4;
                    flareMesh.scale.setScalar(0.8 + (holdTimer / REQUIRED_HOLD) * 0.2);

                    document.getElementById('sync-container').style.opacity = 1;
                    document.getElementById('sync-bar').style.width = `${(holdTimer / REQUIRED_HOLD) * 100}%`;
                    
                    document.getElementById('object-name').innerText = "Hold Steady...";
                    document.getElementById('object-name').style.color = "#55efc4";

                    if (holdTimer >= REQUIRED_HOLD) {
                        isSolved = true;
                        document.getElementById('object-name').innerText = levels[currentLevel].name;
                        document.getElementById('object-name').style.opacity = 1;
                        document.getElementById('object-name').style.color = "#fff";
                        
                        const panel = document.querySelector('.gummy-panel');
                        panel.style.transform = "scale(1.05)";
                        setTimeout(() => panel.style.transform = "scale(1)", 200);
                    }
                } else {
                    if (holdTimer > 0) {
                        holdTimer -= dt * 3.0; 
                        if (holdTimer < 0) holdTimer = 0;
                        document.getElementById('sync-bar').style.width = `${(holdTimer / REQUIRED_HOLD) * 100}%`;
                    } else {
                        document.getElementById('sync-container').style.opacity = 0;
                        document.getElementById('object-name').innerText = "Find the " + levels[currentLevel].name;
                        document.getElementById('object-name').style.color = "#fff";
                    }
                    
                    flareMesh.material.opacity = 0;
                    puzzleGroup.position.set(0,0,0);
                }
                
                puzzleGroup.rotation.z = THREE.MathUtils.lerp(puzzleGroup.rotation.z, 0, 0.02);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        loadLevel(0);
        animate();

    </script>
</body>
</html>
